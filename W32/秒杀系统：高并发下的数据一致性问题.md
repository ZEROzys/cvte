## 秒杀系统：高并发下的数据一致性问题

### 一、MySQL悲观锁/乐观锁机制

#### 1. 悲观锁解决并发问题

总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加（悲观）锁。一旦加锁，不同线程同时执行时,只能有一个线程执行，其他的线程在入口处等待，直到锁被释放。

+ Java的 `synchronized`、`ReentrantLock`
+ 数据库的行锁，表锁等

实现方法：只要在需要查询的sql后面加上`for update`，就能锁住查询的行，**特别要注意查询条件必须要是索引列，如果不是索引就会变成表锁，把整个表都锁住。**

#### 2. 乐观锁解决并发问题

乐观锁顾名思义就是在操作时很乐观，认为操作不会产生并发问题(不会有其他线程对数据进行修改)，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改。

实现方法：版本号机制或者CAS算法

##### 2.1 版本号机制

- 取出记录时，获取当前`version`
- 更新时，带上这个`version`
- 执行更新时， `set version = newVersion where version = oldVersion`
- 如果`version`不对，就更新失败

##### 2.2 CAS 算法

- 需要读写的内存位置`V`
- 进行比较的预期原值`A`
- 拟写入的新值`B`

如果内存位置`V`的值与预期原值`A`相匹配，那么处理器会自动将该位置值更新为新值`B`。

#### 3. 比较

**悲观锁适合写多读少的场景**。因为在使用的时候该线程会独占这个资源。

**乐观锁适合写少读多的场景**。由于乐观锁在发生冲突的时候会回滚或者重试，如果写的请求量很大的话，就经常发生冲突，经常的回滚和重试，这样对系统资源消耗也是非常大。

在阿里巴巴开发手册里也有提到：

> 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。

#### 4. 缺点

对数据库读写造成数据库的巨大压力

### 二、Redis缓存

### 三、消息队列

